---
layout: post
title: Ruby 元编程读书笔记九
excerpt: "代码块"
categories: [Ruby 元编程]
tags: Ruby 元编程
comments: true
---

## Scope Wrap-Up

&emsp;&emsp;每个 Ruby 作用域都包含一组绑定，并且不同的作用域之间被 **作用域门** 分隔开来： **class**、**module** 和 **def**。如果要让一两个绑定穿越作用域门，那么可以用方法调用来替代作用域门：用一个闭包获取当前的绑定，并把这个闭包传递给该方法。你可以使用 Class.new() 方法代替 class，使用 Module.new() 代替 module，以及使用 Module#define_method() 代替 def。这就形成了一个 **扁平作用域**，它是闭包中的一个基本概念。如果在一个扁平作用域中定义了多个方法，则这些方法可以用一个作用域门进行保护，并共享绑定，这种技术称为 **共享作用域**。

## instance_eval()

&emsp;&emsp;Object#instance_eval() 方法可以在一个 **对象的上下文** 中执行一个块：
```ruby
  class MyClass
    def initialize
      @v = 1
    end
  end

  obj = MyClass.new
  obj.instance_eval do
    self                #=> #<MyClass:0x3340dc @v=1>
    @v                  #=> 1
  end
```
&emsp;&emsp;在运行时，该块的接收者会成为 self，因此它可以访问接收者的私有方法和实例变量，例如 @v。instance_eval() 方法甚至可以在不碰其他绑定的情况下修改 self 对象：
```ruby
  v = 2
  obj.instance_eval { @v = v}
  obj.instance_eval { @v }      #=> 2
```
&emsp;&emsp;可以把传递给 instance_eval() 方法的块称为一个 **上下文探针**，因为它就像一个深入到对象中的代码片段，对其进行操作。

#### instance_exec()
