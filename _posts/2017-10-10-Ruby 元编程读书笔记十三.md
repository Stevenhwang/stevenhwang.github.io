---
layout: post
title: Ruby 元编程读书笔记十三
excerpt: "类定义"
categories: [Ruby 元编程]
tags: Ruby 元编程
comments: true
---

### 类变量

&emsp;&emsp;如果希望在类中存储一个变量，那么除了 **类实例变量**，还可以使用以 @@ 开头的 **类变量**。类变量与类实例变量不同，它们可以被子类或类的实例所使用。
```ruby
  class C
    @@v = 1
  end

  class D < C
    def my_method; @@v; end
  end

  D.new.my_method    #=> 1
```

&emsp;&emsp;类是 Class 类的一个实例，所以可以通过调用 Class.new() 方法来创建它。 Class.new() 方法还可以接受一个参数（所建新类的超类）以及一个块：
```ruby
  c = Class.new(Array) do
    def my_method
      'Hello!'
    end
  end
```
&emsp;&emsp;现在虽然有了一个引用类的变量，但是这个类还是匿名的。类名不过是一个常量而已，因此可以来给它赋值：
```ruby
  MyClass = c
```
&emsp;&emsp;这样，该常量就表示这个 class，同时这个 class 也表示这个常量：
```ruby
  c.name    #=> "MyClass"
```

## Singleton Methods

&emsp;&emsp;Ruby 允许给单个对象增加一个方法。
```ruby
  str = "just a regular string"

  def str.title?
    self.upcase == self
  end

  str.title?                    #=> flase
  str.methods.grep(/title?/)    #=> ["title?"]
  str.singleton_methods         #=> ["title?"]
```
&emsp;&emsp;上面的代码为 str 添加了一个 title?() 方法，其他对象则不会得到这个方法----即使是其他的 String 对象。像这样只针对单个对象生效的方法，称为 **单件方法**。

## The Truth About Class Methods

&emsp;&emsp;类只是对象，而类名只是常量，在类上调用方法就跟在对象上调用方法一样：
```ruby
  an_object.a_method
  AClass.a_class_method
```
&emsp;&emsp;类方法的实质就是----它们是一个类的单件方法。如果比较单件方法的定义和类方法的定义，会发现它们是一样的：
```ruby
  def obj.a_singleton_method;end
  def MyClass.another_class_method;end
```
&emsp;&emsp;如果在类定义中写入代码，由于这时 self 就是类本身，所以还可以利用这一点用 self 替换类名来定义类方法：
```ruby
  class MyClass
    def self.yet_another_class_method;end
  end
```

## Class Macros








类方法的定义方式：
第一种
class << HelloWorld
  def hello(name)
    puts "#{name} said hello."
  end
end
第二种
class HelloWorld
  class << self
    def hello(name)
      puts "#{name} said hello."
    end
  end
end
第三种
def HelloWorld.hello(name)
  puts "#{name} said hello."
end
第四种
class HelloWorld
  def self.hello(name)
    puts "#{name} said hello."
  end
end
其中class << 类名 ～ end 这种写法的类定义被称为单例类定义，单例类定义中定义的方法被称为单例方法
通过利用单例类定义，可以给对象添加单例方法，单例类定义也被用于定义对象的专属实例方法：
str1 = "ruby"
str2 = "ruby"
class << str1
  def hello
    "Hello, #{self}!"
  end
end
p str1.hello   #=> "Hello, ruby!"
p str2.hello   #=> NoMethodError

当类包含模块时，它获得的是该模块的实例方法，而不是类方法。
