---
layout: post
title: Ruby 元编程读书笔记二
excerpt: "对象模型"
categories: [Ruby 元编程]
tags: Ruby 元编程
comments: true
---

## Constants

```ruby
  module MyModule
    MyConstant = 'Outer constant'

    class MyClass
      MyConstant = 'Inner constant'
    end
  end
```
>这段代码中的所有常量像文件系统一样组织成树形结构，模块和类像目录，而常量像文件。跟文件系统一样，只要不在同一个目录下，不同文件的文件名可以相同，甚至可以像文件系统一样通过路径方式来引用一个常量。例如，可以这样： MyModule::MyClass::MyConstant 。

```ruby
  module M
    class C
      X = 'a constant'
    end

    C::X          #=> "a constant"
  end

  M::C::X         #=> "a constant"
```
>跟目录文件一样，常量也可以通过路径方式来唯一标识，常量路径使用双冒号进分隔。

```ruby
  module M
    Y = 'another constant'

    class C
      ::M::Y      #=> "another constant"
    end
  end
```
>如果深入探究常量的树形结构，则还可以在常量前加一组双冒号表示根路径，从而得到一个绝对路径。

```ruby
  M.constants                 #=> [:c, :Y]
  Module.constants[0..1]      #=> [:Object, :Module]
```
>Module 类提供了两个叫 constants 的方法，其中一个是实例方法，另一个则是类方法。 Module#constants 方法返回当前范围内的常量，这有点像文件系统中的 ls 命令。 Module.constants 方法返回当前程序中所有顶级常量。

***关于 load 和 require***

&emsp;&emsp;比如想在网上找到一个 motd.rb 文件用来在控制台上显示“当天的消息”， 且想把这段代码集成到最新的程序中去，那么使用 load 执行该文件来显示消息： load('motd.rb')

&emsp;&emsp;不过，使用 load 方法有一个副作用。motd.rb 文件很可能定义了变量和类。**尽管变量在加载完成后会落在当前作用域之外，但常量不会（落在当前作用域中）**。这样，motd.rb 可能会通过它的常量（尤其是类名）污染当前程序的命名空间。

&emsp;&emsp; 可以通过使用第二个可选参数来强制其常量仅在自身范围内有效：load('motd', true)。通过这种方式加载的文件，Ruby 会创建一个匿名模块，使用它作为 **命名空间** 来容纳 motd.rb 中定义的所有常量，加载完成后，该模块会被销毁。

&emsp;&emsp;require 方法与 load 方法颇为类似，但是它的目的不同。通过 load 方法可以执行代码，而 require 则是用来导入类库。这就是 require 方法没有第二个可选参数的原因。在这些库中的类名通常是你导入这些类库时所希望得到的，因此没有理由在加载后销毁它们。


当调用一个方法时，Ruby会做两件事：
1.找到这个方法，这个过程称为方法查找
2.执行这个方法，为了做到这一点需要一个叫做self的东西
为了查找一个方法，Ruby首先在接收者的类中查找，然后一层层地在祖先链中查找，直到找到这个方法为止。可以调用ancestors()方法来获得一个类的祖先链
当调用一个方法时，接收者就成为self,从这一刻起，所有的实例变量都是self的实例变量，所有没有明确指明接收者的方法都在self上调用

Class MyClass
  def testing_self
    @var = 10             #self的一个实例变量
    my_method()           #跟self.my_method()相同
    self
  end

  def my_method
    @var = @var + 1
  end
end

obj = MyClass.new
obj.testing_self      #=> #<MyClass:0*510b44 @var=11>

任何时刻只要调用某个对象的方法，那个对象就成为self。如果还没有调用任何方法，那这时谁是self呢？可以运行irb要答案：
self       #=> main
self.class #=> Object
当开始运行ruby程序时，ruby解释器会创建一个名为main的对象作为当前对象，这个对象有时被称为顶级上下文，这时要么没有调用任何方法，要么调用的所有方法都已经返回了。

ruby的private关键字：私有方法服从一个简单的规则-->不能明确指定一个接收者来调用一个私有方法，因此，只能在自身调用一个私有方法。

** 对象模型小结：**
* 1.对象由一组实例变量和一个类的引用组成
* 2.对象的方法存在于对象所属的类中，从类的角度看，它们叫做实例方法
* 3.类本身是Class类的对象，类的名字不过是一个常量而已
* 4.Class类是Moudle的子类，一个模块基本上是由一组方法组成的包，类除了具有模块的特性之外，还可以被实例化(通过new方法)，及被组织为层次结构(通过superclass方法)
* 5.常量像文件系统一样，是按照树形结构组织的。其中模块名和类的名字扮演目录的角色，其他普通的常量则扮演文件的角色
* 6.每个类都有一个祖先链，这个链从自己所属的类开始，向上直到BasicObject类结束
* 7.当调用一个方法时，Ruby首先向右一步来到接收者所属的类，然后一直向上查找祖先链，直到找到该方法，或者到达链的顶端为止
* 8.每当类包含一个模块时，该模块会被插入到祖先链中，位置在该类的正上方
* 9.当调用一个方法时，接收者会扮演self的角色
* 10.当定义一个模块或者类时，该模块扮演self的角色
* 11.实例变量永远都被认定为self的实例变量
* 12.任何没有明确指定接收者的方法调用，都当成是调用self的方法
